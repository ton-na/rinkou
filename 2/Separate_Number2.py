# 深さ優先探索
def dfs(i, s):
    # 全ての文字を使い切ったら結果を出力
    if i == len(S):
        ans.append(tuple(s))
        return
    # メモ化チェック
    if (i, tuple(s)) in memo:
        ans.extend(memo[(i, tuple(s))])
        return
    # 1桁の数を追加（0でなければ）
    if S[i] != "0":
        # 重複チェック
        if int(S[i]) not in s:
            dfs(i + 1, s + [int(S[i])])
    # 2桁の数を追加（可能かつ0で始まらなければ）
    if i < len(S) - 1 and S[i] != "0":
        # 重複チェック
        if int(S[i:i+2]) not in s:
            dfs(i + 2, s + [int(S[i:i+2])])
    # メモ化更新
    memo[(i, tuple(s))] = list(ans)

# 入力
S = "268668743807663281359259975924239968838915518781704591221216502144648297573337534154488714432458672010933572906012936272617155562367959865483138529186273117849466634478519408432309577699417"

# 数分解の結果を格納するリスト
ans = []

# メモ化用の辞書
memo = {}

# 最初の呼び出し
dfs(0, [])

# 結果の表示
for a in ans:
    print(" ".join(map(str, a)))

# 入力
S = "588023054721923746425265568413319111288895673218269337846703893426741109162458758615749854723538315243686597944776663689752292218713274605143653928349848950941735964090312799751676207148195"

# 数分解の結果を格納するリスト
ans = []

# メモ化用の辞書
memo = {}

# 最初の呼び出し
dfs(0, [])

# 結果の表示
for a in ans:
    print(" ".join(map(str, a)))

# 入力
S = "773181522128748272298129793949024594941105042259227704876614744625899327316561366965719566235587963422604546861151544329262033575401768805730883919989518388467631485645315837491733787983136"

# 数分解の結果を格納するリスト
ans = []

# メモ化用の辞書
memo = {}

# 最初の呼び出し
dfs(0, [])

# 結果の表示
for a in ans:
    print(" ".join(map(str, a)))